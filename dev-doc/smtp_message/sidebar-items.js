initSidebarItems({"enum":[["Command",""],["EnhancedReplyCodeClass",""],["EnhancedReplyCodeSubject",""],["Hostname","Note: comparison happens only on the `raw` field, meaning that if you modify or create a `Hostname` yourself it could have surprising results. But such a `Hostname` would then not actually represent a real hostname, so you probably would have had surprising results anyway."],["Localpart",""],["MaybeUtf8",""],["NextCrLfState",""],["ParameterName",""],["ReplyCodeCategory",""],["ReplyCodeKind",""]],"fn":[["next_crlf","Returns the index of the \\n in the first \\r\\n of buf, or `None` if there was none yet. This will update `state`, the first call should pass in `NextCrLfState::Start`, and subsequent calls (until a non-`None` value is found) should just keep using the same reference."]],"mod":[["fuzz",""]],"struct":[["DataUnescapeRes",""],["DataUnescaper","Helper struct to unescape a data stream."],["Email",""],["EnhancedReplyCode",""],["EscapedDataReader","`AsyncRead` instance that returns an unescaped `DATA` stream."],["EscapingDataWriter","`AsyncWrite` instance that takes an unescaped `DATA` stream and escapes it."],["Parameters","Note: This struct includes the leading ’ ’"],["Path","Note: for convenience this is not exactly like what is described by RFC5321, and it does not contain the Email. Indeed, paths are very rare nowadays."],["Reply",""],["ReplyCode",""],["ReplyLine",""]]});