<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="An in-progress parser for the tokens of a WebAssembly text file."><meta name="keywords" content="rust, rustlang, rust-lang, Parser"><title>Parser in wast::parser - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><script defer src="../../main.js"></script>
    <noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../wast/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../wast/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Parser</a></h2><div class="sidebar-elems"><section><div class="block"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><ul><li><a href="#method.cur_span">cur_span</a></li><li><a href="#method.error">error</a></li><li><a href="#method.is_empty">is_empty</a></li><li><a href="#method.lookahead1">lookahead1</a></li><li><a href="#method.parens">parens</a></li><li><a href="#method.parens_depth">parens_depth</a></li><li><a href="#method.parse">parse</a></li><li><a href="#method.peek">peek</a></li><li><a href="#method.peek2">peek2</a></li><li><a href="#method.peek3">peek3</a></li><li><a href="#method.prev_span">prev_span</a></li><li><a href="#method.register_annotation">register_annotation</a></li><li><a href="#method.step">step</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><ul><li><a href="#impl-Clone">Clone</a></li><li><a href="#impl-Copy">Copy</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul><li><a href="#impl-RefUnwindSafe">!RefUnwindSafe</a></li><li><a href="#impl-Send">!Send</a></li><li><a href="#impl-Sync">!Sync</a></li><li><a href="#impl-Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe">!UnwindSafe</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><ul><li><a href="#impl-Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></li></ul></div></section><h2 class="location"><a href="index.html">In wast::parser</a></h2><div id="sidebar-vars" data-name="Parser" data-ty="struct" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../wast/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Struct <a href="../index.html">wast</a>::<wbr><a href="index.html">parser</a>::<wbr><a class="struct" href="#">Parser</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../src/wast/parser.rs.html#323-325">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="docblock item-decl"><pre class="rust struct"><code>pub struct Parser&lt;'a&gt; { /* private fields */ }</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>An in-progress parser for the tokens of a WebAssembly text file.</p>
<p>A <code>Parser</code> is argument to the <a href="trait.Parse.html" title="Parse"><code>Parse</code></a> trait and is now the input stream is
interacted with to parse new items. Cloning <a href="struct.Parser.html" title="Parser"><code>Parser</code></a> or copying a parser
refers to the same stream of tokens to parse, you cannot clone a <a href="struct.Parser.html" title="Parser"><code>Parser</code></a>
and clone two items.</p>
<p>For more information about a <a href="struct.Parser.html" title="Parser"><code>Parser</code></a> see its methods.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><div id="implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/wast/parser.rs.html#440-937">source</a></span><a href="#impl" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_empty" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/wast/parser.rs.html#450-455">source</a></span><a href="#method.is_empty" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.is_empty" class="fnname">is_empty</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns whether there are no more <code>Token</code> tokens to parse from this
<a href="struct.Parser.html" title="Parser"><code>Parser</code></a>.</p>
<p>This indicates that either we’ve reached the end of the input, or we’re
a sub-<a href="struct.Parser.html" title="Parser"><code>Parser</code></a> inside of a parenthesized expression and we’ve hit the
<code>)</code> token.</p>
<p>Note that if <code>false</code> is returned there <em>may</em> be more comments. Comments
and whitespace are not considered for whether this parser is empty.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.parse" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/wast/parser.rs.html#514-516">source</a></span><a href="#method.parse" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.parse" class="fnname">parse</a>&lt;T:&nbsp;<a class="trait" href="trait.Parse.html" title="trait wast::parser::Parse">Parse</a>&lt;'a&gt;&gt;(self) -&gt; <a class="type" href="type.Result.html" title="type wast::parser::Result">Result</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Parses a <code>T</code> from this <a href="struct.Parser.html" title="Parser"><code>Parser</code></a>.</p>
<p>This method has a trivial definition (it simply calls
<a href="trait.Parse.html#tymethod.parse"><code>T::parse</code></a>) but is here for syntactic purposes. This is
what you’ll call 99% of the time in a <a href="trait.Parse.html" title="Parse"><code>Parse</code></a> implementation in order
to parse sub-items.</p>
<p>Typically you always want to use <code>?</code> with the result of this method, you
should not handle errors and decide what else to parse. To handle
branches in parsing, use <a href="struct.Parser.html#method.peek" title="Parser::peek"><code>Parser::peek</code></a>.</p>
<h5 id="examples"><a href="#examples">Examples</a></h5>
<p>A good example of using <code>parse</code> is to see how the <a href="../core/struct.TableType.html"><code>TableType</code></a> type is
parsed in this crate. A <a href="../core/struct.TableType.html"><code>TableType</code></a> is defined in the official
specification as <a href="https://webassembly.github.io/spec/core/text/types.html#table-types"><code>tabletype</code></a> and is defined as:</p>
<div class="example-wrap"><pre class="language-text"><code>tabletype ::= lim:limits et:reftype</code></pre></div>
<p>so to parse a <a href="../core/struct.TableType.html"><code>TableType</code></a> we recursively need to parse a <a href="../core/struct.Limits.html"><code>Limits</code></a>
and a <a href="../core/struct.RefType.html"><code>RefType</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct</span> <span class="ident">TableType</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="ident">limits</span>: <span class="ident">Limits</span>,
    <span class="ident">elem</span>: <span class="ident">RefType</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">Parse</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">TableType</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">parse</span>(<span class="ident">parser</span>: <span class="ident">Parser</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="comment">// parse the `lim` then `et` in sequence</span>
        <span class="prelude-val">Ok</span>(<span class="ident">TableType</span> {
            <span class="ident">limits</span>: <span class="ident">parser</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>,
            <span class="ident">elem</span>: <span class="ident">parser</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>,
        })
    }
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.peek" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/wast/parser.rs.html#571-573">source</a></span><a href="#method.peek" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.peek" class="fnname">peek</a>&lt;T:&nbsp;<a class="trait" href="trait.Peek.html" title="trait wast::parser::Peek">Peek</a>&gt;(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Performs a cheap test to see whether the current token in this stream is
<code>T</code>.</p>
<p>This method can be used to efficiently determine what next to parse. The
<a href="trait.Peek.html" title="Peek"><code>Peek</code></a> trait is defined for types which can be used to test if they’re
the next item in the input stream.</p>
<p>Nothing is actually parsed in this method, nor does this mutate the
state of this <a href="struct.Parser.html" title="Parser"><code>Parser</code></a>. Instead, this simply performs a check.</p>
<p>This method is frequently combined with the <a href="struct.Parser.html#method.lookahead1" title="Parser::lookahead1"><code>Parser::lookahead1</code></a>
method to automatically produce nice error messages if some tokens
aren’t found.</p>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<p>For an example of using the <code>peek</code> method let’s take a look at parsing
the <a href="../core/struct.Limits.html"><code>Limits</code></a> type. This is <a href="https://webassembly.github.io/spec/core/text/types.html#limits">defined in the official spec</a> as:</p>
<div class="example-wrap"><pre class="language-text"><code>limits ::= n:u32
         | n:u32 m:u32</code></pre></div>
<p>which means that it’s either one <code>u32</code> token or two, so we need to know
whether to consume two tokens or one:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct</span> <span class="ident">Limits</span> {
    <span class="ident">min</span>: <span class="ident">u32</span>,
    <span class="ident">max</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">Parse</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Limits</span> {
    <span class="kw">fn</span> <span class="ident">parse</span>(<span class="ident">parser</span>: <span class="ident">Parser</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="comment">// Always parse the first number...</span>
        <span class="kw">let</span> <span class="ident">min</span> <span class="op">=</span> <span class="ident">parser</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>;

        <span class="comment">// ... and then test if there&#39;s a second number before parsing</span>
        <span class="kw">let</span> <span class="ident">max</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">parser</span>.<span class="ident">peek</span>::<span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>() {
            <span class="prelude-val">Some</span>(<span class="ident">parser</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>)
        } <span class="kw">else</span> {
            <span class="prelude-val">None</span>
        };

        <span class="prelude-val">Ok</span>(<span class="ident">Limits</span> { <span class="ident">min</span>, <span class="ident">max</span> })
    }
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.peek2" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/wast/parser.rs.html#577-584">source</a></span><a href="#method.peek2" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.peek2" class="fnname">peek2</a>&lt;T:&nbsp;<a class="trait" href="trait.Peek.html" title="trait wast::parser::Peek">Peek</a>&gt;(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Same as the <a href="struct.Parser.html#method.peek" title="Parser::peek"><code>Parser::peek</code></a> method, except checks the next token, not
the current token.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.peek3" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/wast/parser.rs.html#588-595">source</a></span><a href="#method.peek3" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.peek3" class="fnname">peek3</a>&lt;T:&nbsp;<a class="trait" href="trait.Peek.html" title="trait wast::parser::Peek">Peek</a>&gt;(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Same as the <a href="struct.Parser.html#method.peek2" title="Parser::peek2"><code>Parser::peek2</code></a> method, except checks the next next token,
not the next token.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lookahead1" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/wast/parser.rs.html#646-651">source</a></span><a href="#method.lookahead1" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.lookahead1" class="fnname">lookahead1</a>(self) -&gt; <a class="struct" href="struct.Lookahead1.html" title="struct wast::parser::Lookahead1">Lookahead1</a>&lt;'a&gt;</h4></section></summary><div class="docblock"><p>A helper structure to perform a sequence of <code>peek</code> operations and if
they all fail produce a nice error message.</p>
<p>This method purely exists for conveniently producing error messages and
provides no functionality that <a href="struct.Parser.html#method.peek" title="Parser::peek"><code>Parser::peek</code></a> doesn’t already give.
The <a href="struct.Lookahead1.html" title="Lookahead1"><code>Lookahead1</code></a> structure has one main method <a href="struct.Lookahead1.html#method.peek" title="Lookahead1::peek"><code>Lookahead1::peek</code></a>,
which is the same method as <a href="struct.Parser.html#method.peek" title="Parser::peek"><code>Parser::peek</code></a>. The difference is that the
<a href="struct.Lookahead1.html#method.error" title="Lookahead1::error"><code>Lookahead1::error</code></a> method needs no arguments.</p>
<h5 id="examples-2"><a href="#examples-2">Examples</a></h5>
<p>Let’s look at the parsing of <a href="../token/enum.Index.html"><code>Index</code></a>. This type is either a <code>u32</code> or
an <a href="../token/struct.Id.html"><code>Id</code></a> and is used in name resolution primarily. The <a href="https://webassembly.github.io/spec/core/text/modules.html#indices">official
grammar for an index</a> is:</p>
<div class="example-wrap"><pre class="language-text"><code>idx ::= x:u32
      | v:id</code></pre></div>
<p>Which is to say that an index is either a <code>u32</code> or an <a href="../token/struct.Id.html"><code>Id</code></a>. When
parsing an <a href="../token/enum.Index.html"><code>Index</code></a> we can do:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">enum</span> <span class="ident">Index</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="ident">Num</span>(<span class="ident">u32</span>),
    <span class="ident">Id</span>(<span class="ident">Id</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>),
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">Parse</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Index</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">parse</span>(<span class="ident">parser</span>: <span class="ident">Parser</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">l</span> <span class="op">=</span> <span class="ident">parser</span>.<span class="ident">lookahead1</span>();
        <span class="kw">if</span> <span class="ident">l</span>.<span class="ident">peek</span>::<span class="op">&lt;</span><span class="ident">Id</span><span class="op">&gt;</span>() {
            <span class="prelude-val">Ok</span>(<span class="ident">Index::Id</span>(<span class="ident">parser</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>))
        } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">l</span>.<span class="ident">peek</span>::<span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>() {
            <span class="prelude-val">Ok</span>(<span class="ident">Index::Num</span>(<span class="ident">parser</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>))
        } <span class="kw">else</span> {
            <span class="comment">// produces error message of `expected identifier or u32`</span>
            <span class="prelude-val">Err</span>(<span class="ident">l</span>.<span class="ident">error</span>())
        }
    }
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.parens" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/wast/parser.rs.html#697-718">source</a></span><a href="#method.parens" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.parens" class="fnname">parens</a>&lt;T&gt;(self, f: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;) -&gt; <a class="type" href="type.Result.html" title="type wast::parser::Result">Result</a>&lt;T&gt;) -&gt; <a class="type" href="type.Result.html" title="type wast::parser::Result">Result</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Parse an item surrounded by parentheses.</p>
<p>WebAssembly’s text format is all based on s-expressions, so naturally
you’re going to want to parse a lot of parenthesized things! As noted in
the documentation of <a href="trait.Parse.html" title="Parse"><code>Parse</code></a> you typically don’t parse your own
surrounding <code>(</code> and <code>)</code> tokens, but the parser above you parsed them for
you. This is method method the parser above you uses.</p>
<p>This method will parse a <code>(</code> token, and then call <code>f</code> on a sub-parser
which when finished asserts that a <code>)</code> token is the next token. This
requires that <code>f</code> consumes all tokens leading up to the paired <code>)</code>.</p>
<p>Usage will often simply be <code>parser.parens(|p| p.parse())?</code> to
automatically parse a type within parentheses, but you can, as always,
go crazy and do whatever you’d like too.</p>
<h5 id="examples-3"><a href="#examples-3">Examples</a></h5>
<p>A good example of this is to see how a <code>Module</code> is parsed. This isn’t
the exact definition, but it’s close enough!</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct</span> <span class="ident">Module</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="ident">fields</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">ModuleField</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">Parse</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Module</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">parse</span>(<span class="ident">parser</span>: <span class="ident">Parser</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="comment">// Modules start out with a `module` keyword</span>
        <span class="ident">parser</span>.<span class="ident">parse</span>::<span class="op">&lt;</span><span class="ident">kw::module</span><span class="op">&gt;</span>()<span class="question-mark">?</span>;

        <span class="comment">// And then everything else is `(field ...)`, so while we&#39;ve got</span>
        <span class="comment">// items left we continuously parse parenthesized items.</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">fields</span> <span class="op">=</span> <span class="ident">Vec::new</span>();
        <span class="kw">while</span> <span class="op">!</span><span class="ident">parser</span>.<span class="ident">is_empty</span>() {
            <span class="ident">fields</span>.<span class="ident">push</span>(<span class="ident">parser</span>.<span class="ident">parens</span>(<span class="op">|</span><span class="ident">p</span><span class="op">|</span> <span class="ident">p</span>.<span class="ident">parse</span>())<span class="question-mark">?</span>);
        }
        <span class="prelude-val">Ok</span>(<span class="ident">Module</span> { <span class="ident">fields</span> })
    }
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.parens_depth" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/wast/parser.rs.html#724-726">source</a></span><a href="#method.parens_depth" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.parens_depth" class="fnname">parens_depth</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Return the depth of nested parens we’ve parsed so far.</p>
<p>This is a low-level method that is only useful for implementing
recursion limits in custom parsers.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.step" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/wast/parser.rs.html#750-757">source</a></span><a href="#method.step" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.step" class="fnname">step</a>&lt;F, T&gt;(self, f: F) -&gt; <a class="type" href="type.Result.html" title="type wast::parser::Result">Result</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="struct" href="struct.Cursor.html" title="struct wast::parser::Cursor">Cursor</a>&lt;'a&gt;) -&gt; <a class="type" href="type.Result.html" title="type wast::parser::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a>T, <a class="struct" href="struct.Cursor.html" title="struct wast::parser::Cursor">Cursor</a>&lt;'a&gt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>A low-level parsing method you probably won’t use.</p>
<p>This is used to implement parsing of the most primitive types in the
<a href="../core/index.html"><code>core</code></a> module. You probably don’t want to use this, but
probably want to use something like <a href="struct.Parser.html#method.parse" title="Parser::parse"><code>Parser::parse</code></a> or
<a href="struct.Parser.html#method.parens" title="Parser::parens"><code>Parser::parens</code></a>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.error" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/wast/parser.rs.html#765-767">source</a></span><a href="#method.error" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.error" class="fnname">error</a>(self, msg: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a>) -&gt; <a class="struct" href="../struct.Error.html" title="struct wast::Error">Error</a></h4></section></summary><div class="docblock"><p>Creates an error whose line/column information is pointing at the
current token.</p>
<p>This is used to produce human-readable error messages which point to the
right location in the input stream, and the <code>msg</code> here is arbitrary text
used to associate with the error and indicate why it was generated.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.cur_span" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/wast/parser.rs.html#774-776">source</a></span><a href="#method.cur_span" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.cur_span" class="fnname">cur_span</a>(&amp;self) -&gt; <a class="struct" href="../token/struct.Span.html" title="struct wast::token::Span">Span</a></h4></section></summary><div class="docblock"><p>Returns the span of the current token</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.prev_span" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/wast/parser.rs.html#779-783">source</a></span><a href="#method.prev_span" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.prev_span" class="fnname">prev_span</a>(&amp;self) -&gt; <a class="struct" href="../token/struct.Span.html" title="struct wast::token::Span">Span</a></h4></section></summary><div class="docblock"><p>Returns the span of the previous token</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.register_annotation" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/wast/parser.rs.html#915-936">source</a></span><a href="#method.register_annotation" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.register_annotation" class="fnname">register_annotation</a>&lt;'b&gt;(self, annotation: &amp;'b <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop">Drop</a> + 'b <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;'a: 'b,&nbsp;</span></h4></section></summary><div class="docblock"><p>Registers a new known annotation with this parser to allow parsing
annotations with this name.</p>
<p><a href="https://github.com/WebAssembly/annotations">WebAssembly annotations</a> are a proposal for the text format
which allows decorating the text format with custom structured
information. By default all annotations are ignored when parsing, but
the whole purpose of them is to sometimes parse them!</p>
<p>To support parsing text annotations this method is used to allow
annotations and their tokens to <em>not</em> be skipped. Once an annotation is
registered with this method, then while the return value has not been
dropped (e.g. the scope of where this function is called) annotations
with the name <code>annotation</code> will be parse of the token stream and not
implicitly skipped.</p>
<h5 id="skipping-annotations"><a href="#skipping-annotations">Skipping annotations</a></h5>
<p>The behavior of skipping unknown/unregistered annotations can be
somewhat subtle and surprising, so if you’re interested in parsing
annotations it’s important to point out the importance of this method
and where to call it.</p>
<p>Generally when parsing tokens you’ll be bottoming out in various
<code>Cursor</code> methods. These are all documented as advancing the stream as
much as possible to the next token, skipping “irrelevant stuff” like
comments, whitespace, etc. The <code>Cursor</code> methods will also skip unknown
annotations. This means that if you parse <em>any</em> token, it will skip over
any number of annotations that are unknown at all times.</p>
<p>To parse an annotation you must, before parsing any token of the
annotation, register the annotation via this method. This includes the
beginning <code>(</code> token, which is otherwise skipped if the annotation isn’t
marked as registered. Typically parser parse the <em>contents</em> of an
s-expression, so this means that the outer parser of an s-expression
must register the custom annotation name, rather than the inner parser.</p>
<h5 id="return"><a href="#return">Return</a></h5>
<p>This function returns an RAII guard which, when dropped, will unregister
the <code>annotation</code> given. Parsing <code>annotation</code> is only supported while the
returned value is still alive, and once dropped the parser will go back
to skipping annotations with the name <code>annotation</code>.</p>
<h5 id="example"><a href="#example">Example</a></h5>
<p>Let’s see an example of how the <code>@name</code> annotation is parsed for modules
to get an idea of how this works:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct</span> <span class="ident">Module</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="ident">name</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">NameAnnotation</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">Parse</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Module</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">parse</span>(<span class="ident">parser</span>: <span class="ident">Parser</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="comment">// Modules start out with a `module` keyword</span>
        <span class="ident">parser</span>.<span class="ident">parse</span>::<span class="op">&lt;</span><span class="ident">kw::module</span><span class="op">&gt;</span>()<span class="question-mark">?</span>;

        <span class="comment">// Next may be `(@name &quot;foo&quot;)`. Typically this annotation would</span>
        <span class="comment">// skipped, but we don&#39;t want it skipped, so we register it.</span>
        <span class="comment">// Note that the parse implementation of</span>
        <span class="comment">// `Option&lt;NameAnnotation&gt;` is the one that consumes the</span>
        <span class="comment">// parentheses here.</span>
        <span class="kw">let</span> <span class="ident">_r</span> <span class="op">=</span> <span class="ident">parser</span>.<span class="ident">register_annotation</span>(<span class="string">&quot;name&quot;</span>);
        <span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="ident">parser</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>;

        <span class="comment">// ... and normally you&#39;d otherwise parse module fields here ...</span>

        <span class="prelude-val">Ok</span>(<span class="ident">Module</span> { <span class="ident">name</span> })
    }
}</code></pre></div>
<p>Another example is how we parse the <code>@custom</code> annotation. Note that this
is parsed as part of <code>ModuleField</code>, so note how the annotation is
registered <em>before</em> we parse the parentheses of the annotation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct</span> <span class="ident">Module</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="ident">fields</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">ModuleField</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">Parse</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Module</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">parse</span>(<span class="ident">parser</span>: <span class="ident">Parser</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="comment">// Modules start out with a `module` keyword</span>
        <span class="ident">parser</span>.<span class="ident">parse</span>::<span class="op">&lt;</span><span class="ident">kw::module</span><span class="op">&gt;</span>()<span class="question-mark">?</span>;

        <span class="comment">// register the `@custom` annotation *first* before we start</span>
        <span class="comment">// parsing fields, because each field is contained in</span>
        <span class="comment">// parentheses and to parse the parentheses of an annotation we</span>
        <span class="comment">// have to known to not skip it.</span>
        <span class="kw">let</span> <span class="ident">_r</span> <span class="op">=</span> <span class="ident">parser</span>.<span class="ident">register_annotation</span>(<span class="string">&quot;custom&quot;</span>);

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">fields</span> <span class="op">=</span> <span class="ident">Vec::new</span>();
        <span class="kw">while</span> <span class="op">!</span><span class="ident">parser</span>.<span class="ident">is_empty</span>() {
            <span class="ident">fields</span>.<span class="ident">push</span>(<span class="ident">parser</span>.<span class="ident">parens</span>(<span class="op">|</span><span class="ident">p</span><span class="op">|</span> <span class="ident">p</span>.<span class="ident">parse</span>())<span class="question-mark">?</span>);
        }
        <span class="prelude-val">Ok</span>(<span class="ident">Module</span> { <span class="ident">fields</span> })
    }
}

<span class="kw">enum</span> <span class="ident">ModuleField</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="ident">Custom</span>(<span class="ident">Custom</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>),
    <span class="comment">// ...</span>
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">Parse</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">ModuleField</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">parse</span>(<span class="ident">parser</span>: <span class="ident">Parser</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="comment">// Note that because we have previously registered the `@custom`</span>
        <span class="comment">// annotation with the parser we known that `peek` methods like</span>
        <span class="comment">// this, working on the annotation token, are enabled to ever</span>
        <span class="comment">// return `true`.</span>
        <span class="kw">if</span> <span class="ident">parser</span>.<span class="ident">peek</span>::<span class="op">&lt;</span><span class="ident">annotation::custom</span><span class="op">&gt;</span>() {
            <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">ModuleField::Custom</span>(<span class="ident">parser</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>));
        }

        <span class="comment">// .. typically we&#39;d parse other module fields here...</span>

        <span class="prelude-val">Err</span>(<span class="ident">parser</span>.<span class="ident">error</span>(<span class="string">&quot;unknown module field&quot;</span>))
    }
}</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Clone" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/wast/parser.rs.html#322">source</a></span><a href="#impl-Clone" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/wast/parser.rs.html#322">source</a></span><a href="#method.clone" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</h4></section></summary><div class='docblock'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#131-133">source</a></span><a href="#method.clone_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self)</h4></section></summary><div class='docblock'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></details></div></details><section id="impl-Copy" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/wast/parser.rs.html#322">source</a></span><a href="#impl-Copy" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</h3></section></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe" class="impl has-srclink"><a href="#impl-RefUnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</h3></section><section id="impl-Send" class="impl has-srclink"><a href="#impl-Send" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</h3></section><section id="impl-Sync" class="impl has-srclink"><a href="#impl-Sync" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</h3></section><section id="impl-Unpin" class="impl has-srclink"><a href="#impl-Unpin" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</h3></section><section id="impl-UnwindSafe" class="impl has-srclink"><a href="#impl-UnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Any" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#132-136">source</a></span><a href="#impl-Any" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#133">source</a></span><a href="#method.type_id" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#209-214">source</a></span><a href="#impl-Borrow%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#211">source</a></span><a href="#method.borrow" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</h4></section></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#218-222">source</a></span><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#219">source</a></span><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</h4></section></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-From%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#554-559">source</a></span><a href="#impl-From%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#556">source</a></span><a href="#method.from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#538-549">source</a></span><a href="#impl-Into%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#546">source</a></span><a href="#method.into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-ToOwned" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#84-96">source</a></span><a href="#impl-ToOwned" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Owned" class="type trait-impl has-srclink"><a href="#associatedtype.Owned" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#89">source</a></span><a href="#method.to_owned" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'><p>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#93">source</a></span><a href="#method.clone_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T)</h4></section></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>)</div></div><div class='docblock'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#595-604">source</a></span><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error" class="type trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#601">source</a></span><a href="#method.try_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#580-589">source</a></span><a href="#impl-TryInto%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-1" class="type trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#586">source</a></span><a href="#method.try_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="wast" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.61.0-nightly (285fa7ecd 2022-03-14)" ></div>
</body></html>