<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A library for to allow multiple return types by automatically generated enum."><meta name="keywords" content="rust, rustlang, rust-lang, auto_enums"><title>auto_enums - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><script defer src="../main.js"></script>
    <noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../auto_enums/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../auto_enums/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Crate auto_enums</a></h2><div class="sidebar-elems"><div class="block"><ul><li class="version">Version 0.7.12</li><li><a id="all-types" href="all.html">All Items</a></li></div></ul><section><div class="block"><ul><li><a href="#attributes">Attribute Macros</a></li></ul></div></section><div id="sidebar-vars" data-name="auto_enums" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../auto_enums/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">auto_enums</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/auto_enums/lib.rs.html#1-884">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A library for to allow multiple return types by automatically generated enum.</p>
<p>This crate is a procedural macro implementation of the features discussions
in [rust-lang/rfcs#2414]. This idea is also known as
[“Anonymous sum types”][rust-lang/rfcs#294].</p>
<p>This library provides the following attribute macros:</p>
<ul>
<li>
<p><code>#[auto_enum]</code></p>
<p>Parses syntax, creates the enum, inserts variants, and passes specified
traits to <code>#[enum_derive]</code>.</p>
</li>
<li>
<p><code>#[enum_derive]</code></p>
<p>Implements specified traits to the enum.</p>
</li>
</ul>
<h2 id="auto_enum"><a href="#auto_enum"><code>#[auto_enum]</code></a></h2>
<p><code>#[auto_enum]</code>’s basic feature is to wrap the value returned by the obvious
branches (<code>match</code>, <code>if</code>, <code>return</code>, etc..) by an enum that implemented the
specified traits.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">auto_enums::auto_enum</span>;

<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
<span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">x</span>: <span class="ident">i32</span>) -&gt; <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="kw">match</span> <span class="ident">x</span> {
        <span class="number">0</span> =&gt; <span class="number">1</span>..<span class="number">10</span>,
        <span class="kw">_</span> =&gt; <span class="macro">vec!</span>[<span class="number">5</span>, <span class="number">10</span>].<span class="ident">into_iter</span>(),
    }
}</code></pre></div>
<p><code>#[auto_enum]</code> generates code in two stages.</p>
<p>First, <code>#[auto_enum]</code> will do the following.</p>
<ul>
<li>parses syntax</li>
<li>creates the enum</li>
<li>inserts variants</li>
</ul>
<p>Code like this will be generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">x</span>: <span class="ident">i32</span>) -&gt; <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="attribute">#[<span class="ident">::auto_enums::enum_derive</span>(<span class="ident">Iterator</span>)]</span>
    <span class="kw">enum</span> <span class="ident">__Enum1</span><span class="op">&lt;</span><span class="ident">__T1</span>, <span class="ident">__T2</span><span class="op">&gt;</span> {
        <span class="ident">__T1</span>(<span class="ident">__T1</span>),
        <span class="ident">__T2</span>(<span class="ident">__T2</span>),
    }

    <span class="kw">match</span> <span class="ident">x</span> {
        <span class="number">0</span> =&gt; <span class="ident">__Enum1::__T1</span>(<span class="number">1</span>..<span class="number">10</span>),
        <span class="kw">_</span> =&gt; <span class="ident">__Enum1::__T2</span>(<span class="macro">vec!</span>[<span class="number">5</span>, <span class="number">10</span>].<span class="ident">into_iter</span>()),
    }
}</code></pre></div>
<p>Next, <code>#[enum_derive]</code> implements the specified traits.</p>
<details>
<summary>Code like this will be generated:</summary>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">x</span>: <span class="ident">i32</span>) -&gt; <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="kw">enum</span> <span class="ident">__Enum1</span><span class="op">&lt;</span><span class="ident">__T1</span>, <span class="ident">__T2</span><span class="op">&gt;</span> {
        <span class="ident">__T1</span>(<span class="ident">__T1</span>),
        <span class="ident">__T2</span>(<span class="ident">__T2</span>),
    }

    <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">__T1</span>, <span class="ident">__T2</span><span class="op">&gt;</span> <span class="ident">::core::iter::Iterator</span> <span class="kw">for</span> <span class="ident">__Enum1</span><span class="op">&lt;</span><span class="ident">__T1</span>, <span class="ident">__T2</span><span class="op">&gt;</span>
    <span class="kw">where</span>
        <span class="ident">__T1</span>: <span class="ident">::core::iter::Iterator</span>,
        <span class="ident">__T2</span>: <span class="ident">::core::iter::Iterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">__T1</span> <span class="kw">as</span> <span class="ident">::core::iter::Iterator</span><span class="op">&gt;</span><span class="ident">::Item</span><span class="op">&gt;</span>,
    {
        <span class="kw">type</span> <span class="ident">Item</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">__T1</span> <span class="kw">as</span> <span class="ident">::core::iter::Iterator</span><span class="op">&gt;</span><span class="ident">::Item</span>;
        <span class="attribute">#[<span class="ident">inline</span>]</span>
        <span class="kw">fn</span> <span class="ident">next</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) -&gt; <span class="ident">::core::option::Option</span><span class="op">&lt;</span><span class="ident"><span class="self">Self</span>::Item</span><span class="op">&gt;</span> {
            <span class="kw">match</span> <span class="self">self</span> {
                <span class="ident">__Enum1::__T1</span>(<span class="ident">x</span>) =&gt; <span class="ident">x</span>.<span class="ident">next</span>(),
                <span class="ident">__Enum1::__T2</span>(<span class="ident">x</span>) =&gt; <span class="ident">x</span>.<span class="ident">next</span>(),
            }
        }
        <span class="attribute">#[<span class="ident">inline</span>]</span>
        <span class="kw">fn</span> <span class="ident">size_hint</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; (<span class="ident">usize</span>, <span class="ident">::core::option::Option</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span>) {
            <span class="kw">match</span> <span class="self">self</span> {
                <span class="ident">__Enum1::__T1</span>(<span class="ident">x</span>) =&gt; <span class="ident">x</span>.<span class="ident">size_hint</span>(),
                <span class="ident">__Enum1::__T2</span>(<span class="ident">x</span>) =&gt; <span class="ident">x</span>.<span class="ident">size_hint</span>(),
            }
        }
    }

    <span class="kw">match</span> <span class="ident">x</span> {
        <span class="number">0</span> =&gt; <span class="ident">__Enum1::__T1</span>(<span class="number">1</span>..<span class="number">10</span>),
        <span class="kw">_</span> =&gt; <span class="ident">__Enum1::__T2</span>(<span class="macro">vec!</span>[<span class="number">5</span>, <span class="number">10</span>].<span class="ident">into_iter</span>()),
    }
}</code></pre></div>
</details>
<br>
<h3 id="nested-armsbranches"><a href="#nested-armsbranches">Nested arms/branches</a></h3>
<p><code>#[auto_enum]</code> can also parse nested arms/branches by using the <code>#[nested]</code>
attribute.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">auto_enums::auto_enum</span>;

<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
<span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">x</span>: <span class="ident">i32</span>) -&gt; <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="kw">match</span> <span class="ident">x</span> {
        <span class="number">0</span> =&gt; <span class="number">1</span>..<span class="number">10</span>,
        <span class="attribute">#[<span class="ident">nested</span>]</span>
        <span class="kw">_</span> =&gt; <span class="kw">match</span> <span class="ident">x</span> {
            <span class="number">1</span> =&gt; <span class="macro">vec!</span>[<span class="number">5</span>, <span class="number">10</span>].<span class="ident">into_iter</span>(),
            <span class="kw">_</span> =&gt; <span class="number">0</span>..<span class="op">=</span><span class="ident">x</span>,
        },
    }
}</code></pre></div>
<p><code>#[nested]</code> can be used basically in the same place as <code>#[auto_enum]</code>,
except that <code>#[nested]</code> cannot be used in functions.</p>
<h3 id="recursion"><a href="#recursion">Recursion</a></h3>
<p>If an error due to recursion occurs, you need to box branches where recursion occurs.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">auto_enums::auto_enum</span>;

<span class="kw">struct</span> <span class="ident">Type</span> {
    <span class="ident">child</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Type</span><span class="op">&gt;</span>,
}

<span class="kw">impl</span> <span class="ident">Type</span> {
    <span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
    <span class="kw">fn</span> <span class="ident">method</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> ()<span class="op">&gt;</span> <span class="op">+</span> <span class="lifetime">&#39;_</span> {
        <span class="kw">if</span> <span class="self">self</span>.<span class="ident">child</span>.<span class="ident">is_empty</span>() {
            <span class="prelude-val">Some</span>(()).<span class="ident">into_iter</span>()
        } <span class="kw">else</span> {
            <span class="comment">// Boxing is only needed on branches where recursion occurs.</span>
            <span class="ident">Box::new</span>(<span class="self">self</span>.<span class="ident">child</span>.<span class="ident">iter</span>().<span class="ident">flat_map</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span>.<span class="ident">method</span>())) <span class="kw">as</span> <span class="ident">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>
        }
    }
}</code></pre></div>
<h3 id="positions-where-auto_enum-can-be-used"><a href="#positions-where-auto_enum-can-be-used">Positions where <code>#[auto_enum]</code> can be used.</a></h3>
<p><code>#[auto_enum]</code> can be used in the following three places. However, since
<a href="https://github.com/rust-lang/rust/issues/15701">stmt_expr_attributes</a> and <a href="https://github.com/rust-lang/rust/issues/54727">proc_macro_hygiene</a> are not stabilized, you need
to use empty <code>#[auto_enum]</code> for functions except nightly.</p>
<ul>
<li>
<p>functions</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">auto_enums::auto_enum</span>;

<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
<span class="kw">fn</span> <span class="ident">func</span>(<span class="ident">x</span>: <span class="ident">i32</span>) -&gt; <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span><span class="op">=</span><span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="kw">if</span> <span class="ident">x</span> <span class="op">==</span> <span class="number">0</span> {
        <span class="prelude-val">Some</span>(<span class="number">0</span>).<span class="ident">into_iter</span>()
    } <span class="kw">else</span> {
        <span class="number">0</span>..<span class="ident">x</span>
    }
}</code></pre></div>
</li>
<li>
<p>expressions</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">auto_enums::auto_enum</span>;

<span class="attribute">#[<span class="ident">auto_enum</span>]</span> <span class="comment">// Nightly does not need an empty attribute to the function.</span>
<span class="kw">fn</span> <span class="ident">expr</span>(<span class="ident">x</span>: <span class="ident">i32</span>) -&gt; <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span><span class="op">=</span><span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
    <span class="kw">match</span> <span class="ident">x</span> {
        <span class="number">0</span> =&gt; <span class="prelude-val">Some</span>(<span class="number">0</span>).<span class="ident">into_iter</span>(),
        <span class="kw">_</span> =&gt; <span class="number">0</span>..<span class="ident">x</span>,
    }
}</code></pre></div>
</li>
<li>
<p>let binding</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">auto_enums::auto_enum</span>;

<span class="attribute">#[<span class="ident">auto_enum</span>]</span> <span class="comment">// Nightly does not need an empty attribute to the function.</span>
<span class="kw">fn</span> <span class="ident">let_binding</span>(<span class="ident">x</span>: <span class="ident">i32</span>) -&gt; <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span><span class="op">=</span><span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
    <span class="kw">let</span> <span class="ident">iter</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">x</span> {
        <span class="number">0</span> =&gt; <span class="prelude-val">Some</span>(<span class="number">0</span>).<span class="ident">into_iter</span>(),
        <span class="kw">_</span> =&gt; <span class="number">0</span>..<span class="ident">x</span>,
    };
    <span class="ident">iter</span>
}</code></pre></div>
</li>
</ul>
<h3 id="supported-syntax"><a href="#supported-syntax">Supported syntax</a></h3>
<ul>
<li>
<p><code>if</code> and <code>match</code></p>
<p>Wrap each branch with a variant.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">auto_enums::auto_enum</span>;

<span class="comment">// if</span>
<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
<span class="kw">fn</span> <span class="ident">expr_if</span>(<span class="ident">x</span>: <span class="ident">i32</span>) -&gt; <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span><span class="op">=</span><span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="kw">if</span> <span class="ident">x</span> <span class="op">==</span> <span class="number">0</span> {
        <span class="prelude-val">Some</span>(<span class="number">0</span>).<span class="ident">into_iter</span>()
    } <span class="kw">else</span> {
        <span class="number">0</span>..<span class="ident">x</span>
    }
}

<span class="comment">// match</span>
<span class="attribute">#[<span class="ident">auto_enum</span>]</span> <span class="comment">// Nightly does not need an empty attribute to the function.</span>
<span class="kw">fn</span> <span class="ident">expr_match</span>(<span class="ident">x</span>: <span class="ident">i32</span>) -&gt; <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span><span class="op">=</span><span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
    <span class="kw">let</span> <span class="ident">iter</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">x</span> {
        <span class="number">0</span> =&gt; <span class="prelude-val">Some</span>(<span class="number">0</span>).<span class="ident">into_iter</span>(),
        <span class="kw">_</span> =&gt; <span class="number">0</span>..<span class="ident">x</span>,
    };
    <span class="ident">iter</span>
}</code></pre></div>
</li>
<li>
<p><code>loop</code></p>
<p>Wrap each <code>break</code> with a variant. Nested loops and labeled <code>break</code> are
also supported.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">auto_enums::auto_enum</span>;

<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
<span class="kw">fn</span> <span class="ident">expr_loop</span>(<span class="kw-2">mut</span> <span class="ident">x</span>: <span class="ident">i32</span>) -&gt; <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="kw">loop</span> {
        <span class="kw">if</span> <span class="ident">x</span> <span class="op">&lt;</span> <span class="number">0</span> {
            <span class="kw">break</span> <span class="ident">x</span>..<span class="number">0</span>;
        } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">x</span> <span class="op">%</span> <span class="number">5</span> <span class="op">==</span> <span class="number">0</span> {
            <span class="kw">break</span> <span class="number">0</span>..<span class="op">=</span><span class="ident">x</span>;
        }
        <span class="ident">x</span> <span class="op">-</span><span class="op">=</span> <span class="number">1</span>;
    }
}</code></pre></div>
</li>
<li>
<p><code>return</code> (in functions)</p>
<p><code>#[auto_enum]</code> can parse the <code>return</code> in the scope.</p>
<p>This analysis is valid only when the return type is <code>impl Trait</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">auto_enums::auto_enum</span>;

<span class="comment">// return (in functions)</span>
<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
<span class="kw">fn</span> <span class="ident">func</span>(<span class="ident">x</span>: <span class="ident">i32</span>) -&gt; <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span><span class="op">=</span><span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="kw">if</span> <span class="ident">x</span> <span class="op">==</span> <span class="number">0</span> {
        <span class="kw">return</span> <span class="prelude-val">Some</span>(<span class="number">0</span>).<span class="ident">into_iter</span>();
    }

    <span class="kw">if</span> <span class="ident">x</span> <span class="op">&gt;</span> <span class="number">0</span> {
        <span class="number">0</span>..<span class="ident">x</span>
    } <span class="kw">else</span> {
        <span class="ident">x</span>..<span class="op">=</span><span class="number">0</span>
    }
}</code></pre></div>
</li>
<li>
<p><code>return</code> (in closures)</p>
<p><code>#[auto_enum]</code> can parse the <code>return</code> in the scope.</p>
<p>This analysis is valid only when the following two conditions are satisfied.</p>
<ul>
<li><code>#[auto_enum]</code> must be used directly for that closure (or the let binding of the closure).</li>
<li><code>?</code> operator not used in the scope.</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">auto_enums::auto_enum</span>;

<span class="comment">// return (in closures)</span>
<span class="attribute">#[<span class="ident">auto_enum</span>]</span> <span class="comment">// Nightly does not need an empty attribute to the function.</span>
<span class="kw">fn</span> <span class="ident">closure</span>() -&gt; <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span><span class="op">=</span><span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
    <span class="kw">let</span> <span class="ident">f</span> <span class="op">=</span> <span class="op">|</span><span class="ident">x</span><span class="op">|</span> {
        <span class="kw">if</span> <span class="ident">x</span> <span class="op">==</span> <span class="number">0</span> {
            <span class="kw">return</span> <span class="prelude-val">Some</span>(<span class="number">0</span>).<span class="ident">into_iter</span>();
        }

        <span class="kw">if</span> <span class="ident">x</span> <span class="op">&gt;</span> <span class="number">0</span> {
            <span class="number">0</span>..<span class="ident">x</span>
        } <span class="kw">else</span> {
            <span class="ident">x</span>..<span class="op">=</span><span class="number">0</span>
        }
    };
    <span class="ident">f</span>(<span class="number">1</span>)
}</code></pre></div>
</li>
<li>
<p><code>?</code> operator (in functions)</p>
<p><code>#[auto_enum]</code> can parse the <code>?</code> operator in the scope.</p>
<p>This analysis is valid only when the return type is <code>Result&lt;T, impl Trait&gt;</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">auto_enums::auto_enum</span>;
<span class="kw">use</span> <span class="ident">std::fmt</span>::{<span class="ident">Debug</span>, <span class="ident">Display</span>};

<span class="comment">// `?` operator (in functions)</span>
<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Debug</span>, <span class="ident">Display</span>)]</span>
<span class="kw">fn</span> <span class="ident">func</span>(<span class="ident">x</span>: <span class="ident">i32</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">i32</span>, <span class="kw">impl</span> <span class="ident">Debug</span> <span class="op">+</span> <span class="ident">Display</span><span class="op">&gt;</span> {
    <span class="kw">if</span> <span class="ident">x</span> <span class="op">==</span> <span class="number">0</span> {
        <span class="prelude-val">Err</span>(<span class="string">&quot;`x` is zero&quot;</span>)<span class="question-mark">?</span>;
    }

    <span class="comment">// The last branch of the function is not parsed.</span>
    <span class="kw">if</span> <span class="ident">x</span> <span class="op">&lt;</span> <span class="number">0</span> {
        <span class="prelude-val">Err</span>(<span class="ident">x</span>)<span class="question-mark">?</span>
    } <span class="kw">else</span> {
        <span class="prelude-val">Ok</span>(<span class="ident">x</span> <span class="op">+</span> <span class="number">1</span>)
    }
}</code></pre></div>
<p><code>?</code> operator is expanded as follows:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">match</span> <span class="ident">expr</span> {
    <span class="prelude-val">Ok</span>(<span class="ident">val</span>) =&gt; <span class="ident">val</span>,
    <span class="prelude-val">Err</span>(<span class="ident">err</span>) =&gt; <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">Enum::Veriant</span>(<span class="ident">err</span>)),
}</code></pre></div>
</li>
<li>
<p><code>?</code> operator (in closures)</p>
<p><code>#[auto_enum]</code> can parse the <code>?</code> operator in the scope.</p>
<p>However, <code>#[auto_enum]</code> must be used directly for that closure
(or the let binding of the closure).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">auto_enums::auto_enum</span>;
<span class="kw">use</span> <span class="ident">std::fmt</span>::{<span class="ident">Debug</span>, <span class="ident">Display</span>};

<span class="comment">// `?` operator (in closures)</span>
<span class="attribute">#[<span class="ident">auto_enum</span>]</span> <span class="comment">// Nightly does not need an empty attribute to the function.</span>
<span class="kw">fn</span> <span class="ident">closure</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">i32</span>, <span class="kw">impl</span> <span class="ident">Debug</span> <span class="op">+</span> <span class="ident">Display</span><span class="op">&gt;</span> {
    <span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Debug</span>, <span class="ident">Display</span>)]</span>
    <span class="kw">let</span> <span class="ident">f</span> <span class="op">=</span> <span class="op">|</span><span class="ident">x</span><span class="op">|</span> {
        <span class="kw">if</span> <span class="ident">x</span> <span class="op">==</span> <span class="number">0</span> {
            <span class="prelude-val">Err</span>(<span class="string">&quot;`x` is zero&quot;</span>)<span class="question-mark">?</span>
        }

        <span class="comment">// The last branch of the function is not interpreted as a branch.</span>
        <span class="kw">if</span> <span class="ident">x</span> <span class="op">&lt;</span> <span class="number">0</span> {
            <span class="prelude-val">Err</span>(<span class="ident">x</span>)<span class="question-mark">?</span>
        } <span class="kw">else</span> {
            <span class="prelude-val">Ok</span>(<span class="ident">x</span> <span class="op">+</span> <span class="number">1</span>)
        }
    };
    <span class="ident">f</span>(<span class="number">1</span>)
}</code></pre></div>
</li>
<li>
<p>Block, unsafe block, method call, parentheses, and type ascription</p>
<p>The following expressions are recursively searched until an <code>if</code>, <code>match</code>,
<code>loop</code> or unsupported expression is found.</p>
<ul>
<li>blocks</li>
<li>unsafe blocks</li>
<li>method calls</li>
<li>parentheses</li>
<li>type ascriptions</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">auto_enums::auto_enum</span>;

<span class="comment">// block</span>
<span class="attribute">#[<span class="ident">auto_enum</span>]</span> <span class="comment">// Nightly does not need an empty attribute to the function.</span>
<span class="kw">fn</span> <span class="ident">expr_block</span>(<span class="ident">x</span>: <span class="ident">i32</span>) -&gt; <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span><span class="op">=</span><span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
    {
        <span class="kw">if</span> <span class="ident">x</span> <span class="op">==</span> <span class="number">0</span> {
            <span class="prelude-val">Some</span>(<span class="number">0</span>).<span class="ident">into_iter</span>()
        } <span class="kw">else</span> {
            <span class="number">0</span>..<span class="ident">x</span>
        }
    }
}

<span class="comment">// method call</span>
<span class="attribute">#[<span class="ident">auto_enum</span>]</span> <span class="comment">// Nightly does not need an empty attribute to the function.</span>
<span class="kw">fn</span> <span class="ident">expr_method</span>(<span class="ident">x</span>: <span class="ident">i32</span>) -&gt; <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span><span class="op">=</span><span class="ident">i32</span><span class="op">&gt;</span> {
   <span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
    <span class="kw">match</span> <span class="ident">x</span> {
        <span class="number">0</span> =&gt; <span class="prelude-val">Some</span>(<span class="number">0</span>).<span class="ident">into_iter</span>(),
        <span class="kw">_</span> =&gt; <span class="number">0</span>..<span class="ident">x</span>,
    }.<span class="ident">map</span>(<span class="op">|</span><span class="ident">y</span><span class="op">|</span> <span class="ident">y</span> <span class="op">+</span> <span class="number">1</span>)
}

<span class="comment">// parentheses</span>
<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
<span class="kw">fn</span> <span class="ident">expr_parentheses</span>(<span class="ident">x</span>: <span class="ident">i32</span>) -&gt; <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span><span class="op">=</span><span class="ident">i32</span><span class="op">&gt;</span> {
    (<span class="kw">if</span> <span class="ident">x</span> <span class="op">==</span> <span class="number">0</span> { <span class="prelude-val">Some</span>(<span class="number">0</span>).<span class="ident">into_iter</span>() } <span class="kw">else</span> { <span class="number">0</span>..<span class="ident">x</span> })
}</code></pre></div>
</li>
</ul>
<h3 id="expression-that-no-value-will-be-returned"><a href="#expression-that-no-value-will-be-returned">Expression that no value will be returned</a></h3>
<p>If the last expression of a branch is one of the following, it is
interpreted that no value will be returned (variant assignment is skipped).</p>
<ul>
<li><code>panic!(..)</code></li>
<li><code>unreachable!(..)</code></li>
<li><code>return</code></li>
<li><code>break</code></li>
<li><code>continue</code></li>
<li><code>None?</code></li>
<li><code>Err(..)?</code></li>
<li>Expression level marker (<code>marker!</code> macro).</li>
<li>An item definition.</li>
</ul>
<p>Also, if the branch contains <code>#[nested]</code>, it is interpreted as returning
an anonymous enum generated by <code>#[auto_enum]</code>, not a value.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">auto_enums::auto_enum</span>;

<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
<span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">x</span>: <span class="ident">i32</span>) -&gt; <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="kw">match</span> <span class="ident">x</span> {
        <span class="number">0</span> =&gt; <span class="number">1</span>..<span class="number">10</span>,
        <span class="number">1</span> =&gt; <span class="macro">panic!</span>(), <span class="comment">// variant assignment is skipped</span>
        <span class="kw">_</span> =&gt; <span class="macro">vec!</span>[<span class="number">5</span>, <span class="number">10</span>].<span class="ident">into_iter</span>(),
    }
}</code></pre></div>
<p>You can also skip that branch explicitly by <code>#[never]</code> attribute.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">auto_enums::auto_enum</span>;

<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
<span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">x</span>: <span class="ident">i32</span>) -&gt; <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="kw">match</span> <span class="ident">x</span> {
        <span class="number">0</span> =&gt; <span class="number">1</span>..<span class="number">10</span>,
        <span class="attribute">#[<span class="ident">never</span>]</span>
        <span class="number">1</span> =&gt; <span class="kw">loop</span> {
            <span class="macro">panic!</span>()
        },
        <span class="kw">_</span> =&gt; <span class="macro">vec!</span>[<span class="number">5</span>, <span class="number">10</span>].<span class="ident">into_iter</span>(),
    }
}</code></pre></div>
<h3 id="expression-level-marker-marker-macro"><a href="#expression-level-marker-marker-macro">Expression level marker (<code>marker!</code> macro)</a></h3>
<p><code>#[auto_enum]</code> replaces <code>marker!</code> macros with variants.
If values of two or more are specified by <code>marker!</code> macros, <code>#[auto_enum]</code>
can be used for unsupported expressions and statements.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">auto_enums::auto_enum</span>;

<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
<span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">x</span>: <span class="ident">i32</span>) -&gt; <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="kw">if</span> <span class="ident">x</span> <span class="op">&lt;</span> <span class="number">0</span> {
        <span class="kw">return</span> <span class="ident">x</span>..<span class="op">=</span><span class="number">0</span>;
    }
    <span class="macro">marker!</span>(<span class="number">1</span>..<span class="number">10</span>)
}</code></pre></div>
<p>The default name of the macro is <code>&quot;marker&quot;</code>, but you can change it by
<code>marker</code> option.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">auto_enums::auto_enum</span>;

<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">marker</span> <span class="op">=</span> <span class="ident">bar</span>, <span class="ident">Iterator</span>)]</span>
<span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">x</span>: <span class="ident">i32</span>) -&gt; <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="kw">if</span> <span class="ident">x</span> <span class="op">&lt;</span> <span class="number">0</span> {
        <span class="kw">return</span> <span class="ident">x</span>..<span class="op">=</span><span class="number">0</span>;
    }
    <span class="macro">bar!</span>(<span class="number">1</span>..<span class="number">10</span>)
}</code></pre></div>
<h3 id="rust-nightly"><a href="#rust-nightly">Rust Nightly</a></h3>
<p>When using <code>#[auto_enum]</code> for expressions and statements, <code>#[auto_enum]</code> for
function is unnecessary.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Add this to your crate root:</span>
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">proc_macro_hygiene</span>, <span class="ident">stmt_expr_attributes</span>)]</span></code></pre></div>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">auto_enums::auto_enum</span>;

<span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">x</span>: <span class="ident">i32</span>) -&gt; <span class="ident">i32</span> {
    <span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
    <span class="kw">let</span> <span class="ident">iter</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">x</span> {
        <span class="number">0</span> =&gt; <span class="number">1</span>..<span class="number">10</span>,
        <span class="kw">_</span> =&gt; <span class="macro">vec!</span>[<span class="number">5</span>, <span class="number">10</span>].<span class="ident">into_iter</span>(),
    };

    <span class="ident">iter</span>.<span class="ident">fold</span>(<span class="number">0</span>, <span class="op">|</span><span class="ident">sum</span>, <span class="ident">x</span><span class="op">|</span> <span class="ident">sum</span> <span class="op">+</span> <span class="ident">x</span>)
}</code></pre></div>
<p>You can also return closures.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Add this to your crate root:</span>
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">fn_traits</span>, <span class="ident">unboxed_closures</span>)]</span></code></pre></div>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">auto_enums::auto_enum</span>;

<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Fn</span>)]</span>
<span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">x</span>: <span class="ident">bool</span>) -&gt; <span class="kw">impl</span> <span class="ident">Fn</span>(<span class="ident">i32</span>) -&gt; <span class="ident">i32</span> {
    <span class="kw">if</span> <span class="ident">x</span> { <span class="op">|</span><span class="ident">y</span><span class="op">|</span> <span class="ident">y</span> <span class="op">+</span> <span class="number">1</span> } <span class="kw">else</span> { <span class="op">|</span><span class="ident">z</span><span class="op">|</span> <span class="ident">z</span> <span class="op">-</span> <span class="number">1</span> }
}</code></pre></div>
<h2 id="enum_derive"><a href="#enum_derive"><code>#[enum_derive]</code></a></h2>
<p><code>#[enum_derive]</code> implements the supported traits and passes unsupported
traits to <code>#[derive]</code>.</p>
<p>If you want to use traits that are not supported by <code>#[enum_derive]</code>, you
can use another crate that provides <a href="https://doc.rust-lang.org/reference/procedural-macros.html#derive-macros">derives macros</a>, or
you can define derives macros yourself (<a href="https://github.com/taiki-e/derive_utils">derive_utils</a> probably can help it).</p>
<p>Basic usage of <code>#[enum_derive]</code></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">auto_enums::enum_derive</span>;

<span class="comment">// `#[enum_derive]` implements `Iterator`, and `#[derive]` implements `Clone`.</span>
<span class="attribute">#[<span class="ident">enum_derive</span>(<span class="ident">Iterator</span>, <span class="ident">Clone</span>)]</span>
<span class="kw">enum</span> <span class="ident">Foo</span><span class="op">&lt;</span><span class="ident">A</span>, <span class="ident">B</span><span class="op">&gt;</span> {
    <span class="ident">A</span>(<span class="ident">A</span>),
    <span class="ident">B</span>(<span class="ident">B</span>),
}</code></pre></div>
<p><code>#[enum_derive]</code> adds the dependency of the specified trait if it is not
specified.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">auto_enums::enum_derive</span>;

<span class="comment">// `#[enum_derive]` implements `Iterator` and `ExactSizeIterator`.</span>
<span class="attribute">#[<span class="ident">enum_derive</span>(<span class="ident">ExactSizeIterator</span>)]</span>
<span class="kw">enum</span> <span class="ident">Foo</span><span class="op">&lt;</span><span class="ident">A</span>, <span class="ident">B</span><span class="op">&gt;</span> {
    <span class="ident">A</span>(<span class="ident">A</span>),
    <span class="ident">B</span>(<span class="ident">B</span>),
}</code></pre></div>
<h2 id="supported-traits"><a href="#supported-traits">Supported traits</a></h2>
<p>Some traits support is disabled by default.
Note that some traits have aliases.</p>
<p><em>When using features that depend on unstable APIs, the <code>unstable</code> feature must be explicitly enabled</em></p>
<h3 id="the-standard-library-std-core"><a href="#the-standard-library-std-core">The standard library (<code>std</code>, <code>core</code>)</a></h3><h4 id="stdcoreiter"><a href="#stdcoreiter"><code>[std|core]::iter</code></a></h4>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/std/iter/iterator.md">generated code</a></li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/std/iter/DoubleEndedIterator.md">generated code</a></li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.ExactSizeIterator.html"><code>ExactSizeIterator</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/std/iter/ExactSizeIterator.md">generated code</a></li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.FusedIterator.html"><code>FusedIterator</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/std/iter/FusedIterator.md">generated code</a></li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Extend.html"><code>Extend</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/std/iter/extend.md">generated code</a></li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.TrustedLen.html"><code>TrustedLen</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/std/iter/TrustedLen.md">generated code</a> <em>(requires <code>&quot;trusted_len&quot;</code> and <code>&quot;unstable&quot;</code> crate features)</em></li>
</ul>
<p><em>See also <a href="https://github.com/taiki-e/iter-enum">iter-enum</a> crate.</em></p>
<h4 id="stdcorefuture"><a href="#stdcorefuture"><code>[std|core]::future</code></a></h4>
<ul>
<li><a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/std/future.md">generated code</a></li>
</ul>
<p><em>See also <a href="https://github.com/taiki-e/futures-enum">futures-enum</a> crate.</em></p>
<h4 id="stdio-requires-std-crate-feature"><a href="#stdio-requires-std-crate-feature"><code>std::io</code> <em>(requires <code>&quot;std&quot;</code> crate feature)</em></a></h4>
<ul>
<li><a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a> (alias: <code>io::Read</code>) - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/std/io/read.md">generated code</a></li>
<li><a href="https://doc.rust-lang.org/std/io/trait.BufRead.html"><code>BufRead</code></a> (alias: <code>io::BufRead</code>) - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/std/io/BufRead.md">generated code</a></li>
<li><a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>Write</code></a> (alias: <code>io::Write</code>) - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/std/io/write.md">generated code</a></li>
<li><a href="https://doc.rust-lang.org/std/io/trait.Seek.html"><code>Seek</code></a> (alias: <code>io::Seek</code>) - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/std/io/seek.md">generated code</a></li>
</ul>
<p><em>See also <a href="https://github.com/taiki-e/io-enum">io-enum</a> crate.</em></p>
<h4 id="stdcoreops"><a href="#stdcoreops"><code>[std|core]::ops</code></a></h4>
<ul>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a> <em>(requires <code>&quot;ops&quot;</code> crate feature)</em></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code>DerefMut</code></a> <em>(requires <code>&quot;ops&quot;</code> crate feature)</em></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Index.html"><code>Index</code></a> <em>(requires <code>&quot;ops&quot;</code> crate feature)</em></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.IndexMut.html"><code>IndexMut</code></a> <em>(requires <code>&quot;ops&quot;</code> crate feature)</em></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.RangeBounds.html"><code>RangeBounds</code></a> <em>(requires <code>&quot;ops&quot;</code> crate feature)</em></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a> <em>(requires <code>&quot;fn_traits&quot;</code> and <code>&quot;unstable&quot;</code> crate features)</em></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a> <em>(requires <code>&quot;fn_traits&quot;</code> and <code>&quot;unstable&quot;</code> crate features)</em></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a> <em>(requires <code>&quot;fn_traits&quot;</code> and <code>&quot;unstable&quot;</code> crate features)</em></li>
<li><a href="https://doc.rust-lang.org/nightly/std/ops/trait.Generator.html"><code>Generator</code></a> <em>(requires <code>&quot;generator_trait&quot;</code> and <code>&quot;unstable&quot;</code> crate features)</em></li>
</ul>
<h4 id="stdcoreconvert"><a href="#stdcoreconvert"><code>[std|core]::convert</code></a></h4>
<ul>
<li><a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>AsRef</code></a> <em>(requires <code>&quot;convert&quot;</code> crate feature)</em></li>
<li><a href="https://doc.rust-lang.org/std/convert/trait.AsMut.html"><code>AsMut</code></a> <em>(requires <code>&quot;convert&quot;</code> crate feature)</em></li>
</ul>
<h4 id="stdcorefmt"><a href="#stdcorefmt"><code>[std|core]::fmt</code></a></h4>
<ul>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a> (alias: <code>fmt::Debug</code>) - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/std/debug.md">generated code</a></li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>Display</code></a> (alias: <code>fmt::Display</code>)</li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Binary.html"><code>fmt::Binary</code></a> <em>(requires <code>&quot;fmt&quot;</code> crate feature)</em></li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.LowerExp.html"><code>fmt::LowerExp</code></a> <em>(requires <code>&quot;fmt&quot;</code> crate feature)</em></li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.LowerHex.html"><code>fmt::LowerHex</code></a> <em>(requires <code>&quot;fmt&quot;</code> crate feature)</em></li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Octal.html"><code>fmt::Octal</code></a> <em>(requires <code>&quot;fmt&quot;</code> crate feature)</em></li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Pointer.html"><code>fmt::Pointer</code></a> <em>(requires <code>&quot;fmt&quot;</code> crate feature)</em></li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.UpperExp.html"><code>fmt::UpperExp</code></a> <em>(requires <code>&quot;fmt&quot;</code> crate feature)</em></li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.UpperHex.html"><code>fmt::UpperHex</code></a> <em>(requires <code>&quot;fmt&quot;</code> crate feature)</em></li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Write.html"><code>fmt::Write</code></a></li>
</ul>
<h4 id="stderror-requires-std-crate-feature"><a href="#stderror-requires-std-crate-feature"><code>std::error</code> <em>(requires <code>&quot;std&quot;</code> crate feature)</em></a></h4>
<ul>
<li><a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/std/error.md">generated code</a></li>
</ul>
<h3 id="external-libraries"><a href="#external-libraries">External libraries</a></h3>
<p>You can use support for external library traits by activating each crate feature.</p>
<p>To use support for external library traits, you need to use the path starting with the feature name. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">auto_enums::auto_enum</span>;
<span class="kw">use</span> <span class="ident">rayon::prelude</span>::<span class="kw-2">*</span>;

<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">rayon::ParallelIterator</span>)]</span> <span class="comment">// Note that this is not `#[auto_enum(ParallelIterator)]`</span>
<span class="kw">fn</span> <span class="ident">func</span>(<span class="ident">x</span>: <span class="ident">i32</span>) -&gt; <span class="kw">impl</span> <span class="ident">ParallelIterator</span> {
    <span class="kw">match</span> <span class="ident">x</span> {
        <span class="number">0</span> =&gt; (<span class="number">1</span>..<span class="number">10</span>).<span class="ident">into_par_iter</span>(),
        <span class="kw">_</span> =&gt; <span class="macro">vec!</span>[<span class="number">5</span>, <span class="number">10</span>].<span class="ident">into_par_iter</span>(),
    }
}</code></pre></div>
<h4 id="futures-v03-requires-futures03-or-futures-crate-feature"><a href="#futures-v03-requires-futures03-or-futures-crate-feature">futures v0.3 <em>(requires <code>&quot;futures03&quot;</code> or <code>&quot;futures&quot;</code> crate feature)</em></a></h4>
<ul>
<li><a href="https://docs.rs/futures/0.3/futures/stream/trait.Stream.html"><code>futures03::Stream</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/external/futures/stream.md">generated code</a></li>
<li><a href="https://docs.rs/futures/0.3/futures/sink/trait.Sink.html"><code>futures03::Sink</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/external/futures/sink.md">generated code</a></li>
<li><a href="https://docs.rs/futures/0.3/futures/io/trait.AsyncRead.html"><code>futures03::AsyncRead</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/external/futures/AsyncRead.md">generated code</a></li>
<li><a href="https://docs.rs/futures/0.3/futures/io/trait.AsyncWrite.html"><code>futures03::AsyncWrite</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/external/futures/AsyncWrite.md">generated code</a></li>
<li><a href="https://docs.rs/futures/0.3/futures/io/trait.AsyncSeek.html"><code>futures03::AsyncSeek</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/external/futures/AsyncSeek.md">generated code</a></li>
<li><a href="https://docs.rs/futures/0.3/futures/io/trait.AsyncBufRead.html"><code>futures03::AsyncBufRead</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/external/futures/AsyncBufRead.md">generated code</a></li>
</ul>
<p><em>See also <a href="https://github.com/taiki-e/futures-enum">futures-enum</a> crate.</em></p>
<h4 id="futures-v01-requires-futures01-crate-feature"><a href="#futures-v01-requires-futures01-crate-feature">futures v0.1 <em>(requires <code>&quot;futures01&quot;</code> crate feature)</em></a></h4>
<ul>
<li><a href="https://docs.rs/futures/0.1/futures/future/trait.Future.html"><code>futures01::Future</code></a></li>
<li><a href="https://docs.rs/futures/0.1/futures/stream/trait.Stream.html"><code>futures01::Stream</code></a></li>
<li><a href="https://docs.rs/futures/0.1/futures/sink/trait.Sink.html"><code>futures01::Sink</code></a></li>
</ul>
<h4 id="rayon-requires-rayon-crate-feature"><a href="#rayon-requires-rayon-crate-feature">rayon <em>(requires <code>&quot;rayon&quot;</code> crate feature)</em></a></h4>
<ul>
<li><a href="https://docs.rs/rayon/1/rayon/iter/trait.ParallelIterator.html"><code>rayon::ParallelIterator</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/external/rayon/ParallelIterator.md">generated code</a></li>
<li><a href="https://docs.rs/rayon/1/rayon/iter/trait.IndexedParallelIterator.html"><code>rayon::IndexedParallelIterator</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/external/rayon/IndexedParallelIterator.md">generated code</a></li>
<li><a href="https://docs.rs/rayon/1/rayon/iter/trait.ParallelExtend.html"><code>rayon::ParallelExtend</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/external/rayon/ParallelExtend.md">generated code</a></li>
</ul>
<h4 id="serde-requires-serde-crate-feature"><a href="#serde-requires-serde-crate-feature">serde <em>(requires <code>&quot;serde&quot;</code> crate feature)</em></a></h4>
<ul>
<li><a href="https://docs.rs/serde/1/serde/trait.Serialize.html"><code>serde::Serialize</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/external/serde/serialize.md">generated code</a></li>
</ul>
<h4 id="tokio-v1-requires-tokio1-crate-feature"><a href="#tokio-v1-requires-tokio1-crate-feature">tokio v1 <em>(requires <code>&quot;tokio1&quot;</code> crate feature)</em></a></h4>
<ul>
<li><a href="https://docs.rs/tokio/1/tokio/io/trait.AsyncRead.html"><code>tokio1::AsyncRead</code></a></li>
<li><a href="https://docs.rs/tokio/1/tokio/io/trait.AsyncWrite.html"><code>tokio1::AsyncWrite</code></a></li>
<li><a href="https://docs.rs/tokio/1/tokio/io/trait.AsyncSeek.html"><code>tokio1::AsyncSeek</code></a></li>
<li><a href="https://docs.rs/tokio/1/tokio/io/trait.AsyncBufRead.html"><code>tokio1::AsyncBufRead</code></a></li>
</ul>
<h4 id="tokio-v03-requires-tokio03-crate-feature"><a href="#tokio-v03-requires-tokio03-crate-feature">tokio v0.3 <em>(requires <code>&quot;tokio03&quot;</code> crate feature)</em></a></h4>
<ul>
<li><a href="https://docs.rs/tokio/0.3/tokio/io/trait.AsyncRead.html"><code>tokio03::AsyncRead</code></a></li>
<li><a href="https://docs.rs/tokio/0.3/tokio/io/trait.AsyncWrite.html"><code>tokio03::AsyncWrite</code></a></li>
<li><a href="https://docs.rs/tokio/0.3/tokio/io/trait.AsyncSeek.html"><code>tokio03::AsyncSeek</code></a></li>
<li><a href="https://docs.rs/tokio/0.3/tokio/io/trait.AsyncBufRead.html"><code>tokio03::AsyncBufRead</code></a></li>
</ul>
<h4 id="tokio-v02-requires-tokio02-crate-feature"><a href="#tokio-v02-requires-tokio02-crate-feature">tokio v0.2 <em>(requires <code>&quot;tokio02&quot;</code> crate feature)</em></a></h4>
<ul>
<li><a href="https://docs.rs/tokio/0.2/tokio/io/trait.AsyncRead.html"><code>tokio02::AsyncRead</code></a></li>
<li><a href="https://docs.rs/tokio/0.2/tokio/io/trait.AsyncWrite.html"><code>tokio02::AsyncWrite</code></a></li>
<li><a href="https://docs.rs/tokio/0.2/tokio/io/trait.AsyncSeek.html"><code>tokio02::AsyncSeek</code></a></li>
<li><a href="https://docs.rs/tokio/0.2/tokio/io/trait.AsyncBufRead.html"><code>tokio02::AsyncBufRead</code></a></li>
</ul>
<h4 id="tokio-v01-requires-tokio01-crate-feature"><a href="#tokio-v01-requires-tokio01-crate-feature">tokio v0.1 <em>(requires <code>&quot;tokio01&quot;</code> crate feature)</em></a></h4>
<ul>
<li><a href="https://docs.rs/tokio/0.1/tokio/io/trait.AsyncRead.html"><code>tokio01::AsyncRead</code></a></li>
<li><a href="https://docs.rs/tokio/0.1/tokio/io/trait.AsyncWrite.html"><code>tokio01::AsyncWrite</code></a></li>
</ul>
<h3 id="inherent-methods"><a href="#inherent-methods">Inherent methods</a></h3>
<p>These don’t derive traits, but derive inherent methods instead.</p>
<ul>
<li>
<p><code>Transpose</code> <em>(requires <code>&quot;transpose_methods&quot;</code> crate feature)</em> - this derives the following conversion methods.</p>
<ul>
<li>
<p><code>transpose</code> — convert from <code>enum&lt;Option&lt;T1&gt;,..&gt;</code> to <code>Option&lt;enum&lt;T1,..&gt;&gt;</code></p>
</li>
<li>
<p><code>transpose</code> — convert from <code>enum&lt;Result&lt;T1, E1&gt;,..&gt;</code> to <code>Result&lt;enum&lt;T1,..&gt;, enum&lt;E1,..&gt;&gt;</code></p>
</li>
<li>
<p><code>transpose_ok</code> — convert from <code>enum&lt;Result&lt;T1, E&gt;,..&gt;</code> to <code>Option&lt;enum&lt;T1,..&gt;, E&gt;</code></p>
<p>Examples:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">auto_enums::auto_enum</span>;
<span class="kw">use</span> <span class="ident">std</span>::{<span class="ident">fs</span>, <span class="ident">io</span>, <span class="ident">path::Path</span>};

<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Transpose</span>, <span class="ident">Write</span>)]</span>
<span class="kw">fn</span> <span class="ident">output_stream</span>(<span class="ident">file</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">Path</span><span class="op">&gt;</span>) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span><span class="kw">impl</span> <span class="ident">io::Write</span><span class="op">&gt;</span> {
    <span class="kw">match</span> <span class="ident">file</span> {
        <span class="prelude-val">Some</span>(<span class="ident">f</span>) =&gt; <span class="ident">fs::File::create</span>(<span class="ident">f</span>),
        <span class="prelude-val">None</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident">io::stdout</span>()),
    }.<span class="ident">transpose_ok</span>()
}</code></pre></div>
</li>
<li>
<p><code>transpose_err</code> — convert from <code>enum&lt;Result&lt;T, E1&gt;,..&gt;</code> to <code>Result&lt;T, enum&lt;E1,..&gt;&gt;</code></p>
</li>
</ul>
</li>
</ul>
<h2 id="optional-features"><a href="#optional-features">Optional features</a></h2>
<ul>
<li><strong><code>std</code></strong> <em>(enabled by default)</em>
<ul>
<li>Enable to use <code>std</code> library’s traits.</li>
</ul>
</li>
<li><strong><code>ops</code></strong>
<ul>
<li>Enable to use <code>[std|core]::ops</code>’s <code>Deref</code>, <code>DerefMut</code>, <code>Index</code>, <code>IndexMut</code>, and <code>RangeBounds</code> traits.</li>
</ul>
</li>
<li><strong><code>convert</code></strong>
<ul>
<li>Enable to use <code>[std|core]::convert</code>’s <code>AsRef</code> and <code>AsMut</code> traits.</li>
</ul>
</li>
<li><strong><code>fmt</code></strong>
<ul>
<li>Enable to use <code>[std|core]::fmt</code>’s traits other than <code>Debug</code>, <code>Display</code> and <code>Write</code>.</li>
</ul>
</li>
<li><strong><code>transpose_methods</code></strong>
<ul>
<li>Enable to use <code>transpose*</code> methods.</li>
</ul>
</li>
<li><strong><code>futures03</code></strong>
<ul>
<li>Enable to use <a href="https://docs.rs/futures/0.3">futures v0.3</a> traits.</li>
</ul>
</li>
<li><strong><code>futures01</code></strong>
<ul>
<li>Enable to use <a href="https://docs.rs/futures/0.1">futures v0.1</a> traits.</li>
</ul>
</li>
<li><strong><code>rayon</code></strong>
<ul>
<li>Enable to use <a href="https://docs.rs/rayon/1">rayon</a> traits.</li>
</ul>
</li>
<li><strong><code>serde</code></strong>
<ul>
<li>Enable to use <a href="https://docs.rs/serde/1">serde</a> traits.</li>
</ul>
</li>
<li><strong><code>tokio1</code></strong>
<ul>
<li>Enable to use <a href="https://docs.rs/tokio/1">tokio v1</a> traits.</li>
</ul>
</li>
<li><strong><code>tokio03</code></strong>
<ul>
<li>Enable to use <a href="https://docs.rs/tokio/0.3">tokio v0.3</a> traits.</li>
</ul>
</li>
<li><strong><code>tokio02</code></strong>
<ul>
<li>Enable to use <a href="https://docs.rs/tokio/0.2">tokio v0.2</a> traits.</li>
</ul>
</li>
<li><strong><code>tokio01</code></strong>
<ul>
<li>Enable to use <a href="https://docs.rs/tokio/0.1">tokio v0.1</a> traits.</li>
</ul>
</li>
<li><strong><code>generator_trait</code></strong>
<ul>
<li>Enable to use <code>[std|core]::ops::Generator</code> trait.</li>
<li>Note that this feature is unstable and may cause incompatible changes between patch versions.</li>
</ul>
</li>
<li><strong><code>fn_traits</code></strong>
<ul>
<li>Enable to use <code>[std|core]::ops</code>’s <code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code> traits.</li>
<li>Note that this feature is unstable and may cause incompatible changes between patch versions.</li>
</ul>
</li>
<li><strong><code>trusted_len</code></strong>
<ul>
<li>Enable to use <code>[std|core]::iter::TrustedLen</code> trait.</li>
<li>Note that this feature is unstable and may cause incompatible changes between patch versions.</li>
</ul>
</li>
</ul>
<h3 id="type_analysis-feature"><a href="#type_analysis-feature"><code>type_analysis</code> feature</a></h3>
<p>Analyze return type of function and <code>let</code> binding.</p>
<p><em>Note that this feature is still experimental.</em></p>
<p>Examples:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">auto_enums::auto_enum</span>;

<span class="attribute">#[<span class="ident">auto_enum</span>]</span> <span class="comment">// there is no need to specify std library&#39;s traits</span>
<span class="kw">fn</span> <span class="ident">func1</span>(<span class="ident">x</span>: <span class="ident">i32</span>) -&gt; <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="kw">match</span> <span class="ident">x</span> {
        <span class="number">0</span> =&gt; <span class="number">1</span>..<span class="number">10</span>,
        <span class="kw">_</span> =&gt; <span class="macro">vec!</span>[<span class="number">5</span>, <span class="number">10</span>].<span class="ident">into_iter</span>(),
    }
}

<span class="attribute">#[<span class="ident">auto_enum</span>]</span>
<span class="kw">fn</span> <span class="ident">func2</span>(<span class="ident">x</span>: <span class="ident">i32</span>) {
    <span class="comment">// Unlike `feature(impl_trait_in_bindings)`, this works on stable compilers.</span>
    <span class="attribute">#[<span class="ident">auto_enum</span>]</span>
    <span class="kw">let</span> <span class="ident">iter</span>: <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">x</span> {
        <span class="number">0</span> =&gt; <span class="prelude-val">Some</span>(<span class="number">0</span>).<span class="ident">into_iter</span>(),
        <span class="kw">_</span> =&gt; <span class="number">0</span>..<span class="ident">x</span>,
    };
}</code></pre></div>
<p>Please be careful if you return another traits with the same name.</p>
<h2 id="known-limitations"><a href="#known-limitations">Known limitations</a></h2>
<ul>
<li>There needs to explicitly specify the trait to be implemented (<code>type_analysis</code> crate feature reduces this limitation).</li>
<li>There needs to be marker macros for unsupported expressions.</li>
</ul>
</div></details><h2 id="attributes" class="small-section-header"><a href="#attributes">Attribute Macros</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="attr" href="attr.auto_enum.html" title="auto_enums::auto_enum attr">auto_enum</a></div><div class="item-right docblock-short"><p>An attribute macro for to allow multiple return types by automatically generated enum.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="attr" href="attr.enum_derive.html" title="auto_enums::enum_derive attr">enum_derive</a></div><div class="item-right docblock-short"><p>An attribute macro like a wrapper of <code>#[derive]</code>, implementing
the supported traits and passing unsupported traits to <code>#[derive]</code>.</p>
</div></div></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="auto_enums" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.61.0-nightly (285fa7ecd 2022-03-14)" ></div>
</body></html>